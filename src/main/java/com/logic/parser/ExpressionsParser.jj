options {
    STATIC = false;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(ExpressionsParser)

package com.logic.parser;

import com.logic.asts.*;
import com.logic.asts.binary.*;
import com.logic.asts.unary.*;
import com.logic.asts.others.*;

public class ExpressionsParser {
}

PARSER_END(ExpressionsParser)

SKIP : {
    " "
  | "\t"
  | "\r"
  | < ENTER: "\n">
  | <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
  | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : {
    < SF: "SF" >
  | < SP: "SP" >
}

TOKEN : {
    < LPAR : "(" >
  | < RPAR : ")" >
  | < TOP: "⊤" >
  | < BOTTOM: "⊥" >
  | < NOT: "¬" >
  | < AND: "∧" >
  | < OR: "∨" >
  | < CONDITIONAL: "→" >
  | < BICONDITIONAL: "↔" >
  | < UNIVERSAL: "∀" >
  | < EXISTENTIAL: "∃" >
  | < SLASH: "/" >
  | < COMMA : "," >
  | < GREEK : ("φ" | "δ" | "ψ" | "α" | "β" | "γ" | "ε" | "λ" | "μ" | "ρ" | "σ" | "τ" | "ω") >
  | < U_CHAR: ["A"-"Z"] >
  | < U_WORD: ["A"-"Z"] (["a"-"z", "A"-"Z"])+ >
  | < L_CHAR: (["a"-"z"]) >
  | < L_WORD: ["a"-"z"] (["a"-"z", "A"-"Z"])+ >
  | < DOT: ".">
  | < EQUALS: "=">
  | < LBRA : "{" >
  | < RBRA : "}" >
  | < NUMBER: (["0"-"9"])+ >
}

/*
* Parser for propositional logic expressions
*/
IASTExp parsePL() : {
    IASTExp e;
} {
    e = sequencesPL() <EOF>
    { return e; }
}

private IASTExp sequencesPL() : {
    ASTSequence exps;
    IASTExp e;
} {
    e = operations() { exps = new ASTSequence(e); }
    ( e = operations() { exps.addExp(e); } )*
    { return exps; }
}

private IASTExp operations() : {
    IASTExp e1, e2;
} {
    e1 = atomicsPL()
    (
        <AND> e2 = atomicsPL() { e1 = new ASTAnd(e1, e2); }
      | <OR> e2 = atomicsPL() { e1 = new ASTOr(e1, e2); }
      | <CONDITIONAL> e2 = atomicsPL() { e1 = new ASTConditional(e1, e2); }
      | <BICONDITIONAL> e2 = atomicsPL() { e1 = new ASTBiconditional(e1, e2); }
    )?
    { return e1; }
}

private IASTExp atomicsPL() : {
    Token t;
    IASTExp e;
} {
    <TOP> { return new ASTTop(); }
  | <BOTTOM> { return new ASTBottom(); }
  | <NOT> e = atomicsPL() { return new ASTNot(e); }
  | <LPAR> e = operations() <RPAR> { return new ASTParenthesis(e); }
  | t = <L_CHAR> { return new ASTLiteral(t.image); }
  | t = <GREEK> { return new ASTLiteral(t.image); }
}

/*
* Parser for first-order logic expressions
*/

IASTExp parseFOL() : {
    IASTExp e;
} {
    e = sequencesFOL() <EOF>
    { return e; }
}

private IASTExp sequencesFOL() : {
    ASTSequence exps;
    IASTExp e;
} {
    e = signaturesFOL() { exps = new ASTSequence(e); }
    ( e = signaturesFOL() { exps.addExp(e); } )*
    { return exps; }
}

private IASTExp signaturesFOL() : {
    IASTExp e;

    Token name, arity;
    ASTSigFun fun = new ASTSigFun();
    ASTSigPred pred = new ASTSigPred();
} {
    e = operationsFOL() { return e; }
    | <SF> <EQUALS> <LBRA> e = signaturesSFFOL() <RBRA> { return e; }
    | <SP> <EQUALS> <LBRA> e = signaturesSPFOL() <RBRA> { return e; }
}

private IASTExp signaturesSFFOL() : {
    String name;
    Token arity;
    ASTSigFun fun = new ASTSigFun();
} {
        name = funName() <SLASH> arity = <NUMBER> {fun.addFunction(name, arity.image); }
         ( <COMMA> name = funName() <SLASH> arity = <NUMBER> {fun.addFunction(name, arity.image);})*
         { return fun; }
}

private IASTExp signaturesSPFOL() : {
    String name;
    Token arity;
    ASTSigPred pred = new ASTSigPred();
} {
        name = predName() <SLASH> arity = <NUMBER> {pred.addPredicate(name, arity.image); }
         ( <COMMA> name = predName() <SLASH> arity = <NUMBER> {pred.addPredicate(name, arity.image);})*
         { return pred; }
}

private IASTExp operationsFOL() : {
    IASTExp e1, e2;
} {
    e1 = atomicsFOL()
    (
        <AND> e2 = atomicsFOL() { e1 = new ASTAnd(e1, e2); }
      | <OR> e2 = atomicsFOL() { e1 = new ASTOr(e1, e2); }
      | <CONDITIONAL> e2 = atomicsFOL() { e1 = new ASTConditional(e1, e2); }
      | <BICONDITIONAL> e2 = atomicsFOL() { e1 = new ASTBiconditional(e1, e2); }
    )?
    { return e1; }
}

private IASTExp atomicsFOL() : {
    Token t;
    IASTExp e, e1;
    ASTPred pred;
    String name;
} {
    <TOP> { return new ASTTop(); }
  | <BOTTOM> { return new ASTBottom(); }
  | <NOT> e = atomicsFOL() { return new ASTNot(e); }
  | <LPAR> e = operationsFOL() <RPAR> { return new ASTParenthesis(e); }
  | t = <GREEK> { return new ASTLiteral(t.image); }
  | <EXISTENTIAL> t = <L_CHAR> {e = new ASTBasicTerm(t.image);} e1 = atomicsFOL() { return new ASTExistential(e, e1); }
  | <UNIVERSAL> t = <L_CHAR> {e = new ASTBasicTerm(t.image);} e1 = atomicsFOL() { return new ASTUniversal(e, e1); }
  | name = predName() e = predicateFOL(name) {return  e;}
}

private IASTExp predicateFOL(String name) : {
    IASTExp e;
    ASTPred pred = new ASTPred(name);
} {
    <LPAR> e = termFOL() { pred.addTerm(e); } ( <COMMA> e = termFOL() { pred.addTerm(e); } )* <RPAR> {return pred; }
}

private IASTExp termFOL() : {
   Token t;
   IASTExp e;
   ASTFun fun;
} {
    t = <L_CHAR> (e = functionFOL(t.image) { return e; } | { return new ASTBasicTerm(t.image); })
  | t = <L_WORD> (e = functionFOL(t.image) { return e; } | { return new ASTBasicTerm(t.image); })
}

private IASTExp functionFOL(String name) : {
    IASTExp e;
    ASTFun fun = new ASTFun(name);
} {
    <LPAR> e = termFOL() { fun.addTerm(e); } ( <COMMA> e = termFOL() { fun.addTerm(e); } )* <RPAR> { return fun; }
}

private String funName() : {
    Token t;
} {
    t = <L_CHAR> { return t.image; }
    | t = <L_WORD> { return t.image; }
}

private String predName() : {
    Token t;
} {
    t = <U_CHAR> { return t.image; }
    | t = <U_WORD> { return t.image; }
}

